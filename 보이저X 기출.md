# 보이저X
https://v6xcareer.notion.site/2f61a1b40c81495eaf564cde9efc6089

<br>


### Base64 인코딩이란? (기출) 

<details>
   <summary> 답안 보기 (👈 Click)</summary>
[참고: https://base64.guru/]
   
+ Base64는 가장 인기 있는 binary-to-text 알고리즘으로서, 데이터를 일반 텍스트로 변환함으로써, <br> 
  다른 저장 매체간에 전송시 데이터 변조를 예방합니다. <br> 
  게다가, 이것은 종종 이진 데이터를 text 문서, 예를 들어 HTML, CSS, Javascript 혹은 XML 등에 삽입하는데 사용됩니다. <br> 
  알고리즘의 높은 인기를 감안할 때, Base64는 매우 잘 문서화되어 있고, 여러 프로그래밍 언어에 의해 지원되며, 여러 수정본을 낳았으며, <br> 
  자신만의 명세를 갖고 있습니다. <br> 
  그러나, 이상하게 들릴 수도 있지만, 이 알고리즘에 대한 공식 사이트는 존재하지 않습니다. <br> 
   
  Base64는 인코딩 알고리즘으로서, 어떤 문자든 라틴 문자, 숫자, +, /를 포함한 알파벳으로 변환해줍니다. <br> 
  이것으로 인해, 당신은 중국 문자, 이모티콘, 심지어는 이미지도 "읽을만한" 문자열로서 변환해, 어디서든 저장되거나 전송될 수 있습니다. <br> 
   
  왜 Base64가 발명되었는지 비유적으로 이해하기 위해서, 엘리스가 전화통화 도중 밥에게 이미지를 보내고 싶다고 가정해봅시다. <br> 
  첫번째 문제는 그녀가 이미지가 어떤지 간단하게 묘사할 수 없다는 점인데, 왜냐하면 밥은 정확한 복사본이 필요하기 때문입니다. <br> 
  이 경우 엘리스는 이미지를 이진 시스템으로 변환해서, 밥에게 이진 비트들을 전달하는데, <br>
  그 후에 그는 그것을 원본 이미지로 변환할 수 있습니다. <br>
   
  두 번째 문제는 전화 요금이 너무 비싸서, 각 바이트를 8자리 숫자로 전달하기에는 너무 시간이 오래 걸린다는 점입니다. <br> 
  비용을 낮추기 위해서, 엘리스와 밥은 특별한 알파벳을 이용해서 더 효율적인 데이터 교환 방법을 사용하는 것에 동의했는데, <br> 
  그것은 각 6비트마다 한 개의 문자로 대체하는 것입니다. <br>
   
  차이를 인식하기 위해서, 5x5 이미지를 이진 숫자로 변환한 것을 확인하라
  ```
   010001 110100 100101 000110 001110 000011 011101 100001 000000 010000 000000 000001 000000 001111 000000 000000 000000 001111 111100 000000 000000 000000 000000     000000 000000 000010 110000 000000 000000 000000 000000 000000 000000 010000 000000 000001 000000 000000 000000 000010 000000 100100 010000 000001 000000 000011 001011
  ``` 
  같은 이미지가 Base64 로 변환되면 다음과 같이 보입니다. 
  ```
   R0lGODdhAQABAPAAAP8AAAAAACwAAAAAAQABAAACAkQBADs
  ``` 
  내 생각에 차이점은 분명합니다. 당신이 빈 공간이나 padding 0을 이진 비트에서 삭제하더라도, Base64 문자열은 더 짧을 것입니다. <br>
  나는 각각의 그룹이 Base64 문자열의 각각의 문자에 대응된다는 것을 보이기 위해서 비트들을 그룹핑했습니다. <br> 
   
  엘리스와 밥의 스토리는 Base64알고리즘이 어떤 문제를 푸는지에 대한 사고 예시입니다. <br> 
  사실, 이것은 binary-to-text 인코딩이고, 
  데이터 전송 채널이나 저장 매체가 8비트 문자 인코딩을 다루지 못할 때, 이진 데이터를 출력 가능한 문자로 전환합니다.  <br> 
   
</details>


-----------------------

### HTTP/2란? (기출) 

<details>
   <summary> 답안 보기 (👈 Click)</summary>
[참고: HTTP 완벽 가이드 p.287]
   
+ HTTP 명세를 만들어 온 HTTP 작업 그룹은 HTTP의 성능 문제를 개선하기 위해, <br> 
  HTTP 2.0을 만드는 작업을 한창 진행중입니다. <br> 
  이 장에서는 HTTP/2.0에 대해, 만들기 시작하게 된 배경, HTTP/1.1과의 주요 차이점, 현재까지 알려진 보안 이슈 <br>
  에 대해 이야기합니다. <br> 
   
  이 장은 HTTP/2.0의 8번째 초안에 기반하여 작성되었습니다. <br> 
  이후 이 장에서 HTTP/2.0 초안 이라고 하면 이 8번째 초안을 말하는 것입니다. <br> 
  HTTP/2.0 명세는 계속해서 고쳐지고 있는 중이므로, 이 장의 내용은 독자가 이 책을 읽고 있는 시점에서의 HTTP/2.0 명세의 내용과 <br> 
  차이가 있을 수 있습니다. <br> 
</details>
 
-----------------------

### HTTP/2의 등장 배경은? (기출) 

<details>
   <summary> 답안 보기 (👈 Click)</summary>
[참고: HTTP 완벽 가이드 p.287]
   
+ HTTP/1.1의 메시지 포맷은 구현의 단순성과 접근성에 주안점을 두고, 최적화 되었습니다. <br> 
  그러다 보니 성능은 어느 정도 희생시키지 않을 수 없었습니다. <br> 
  커넥션 하나를 통해 요청 하나를 보내고 그에 대해 응답 하나만을 받는 HTTP의 메시지 교환 방식은 단순함 면에서는 <br> 
  더할 나위 없었지만, 응답을 받아야만 그 다음 요청을 보낼 수 있기 때문에 심각한 회전 지연(latency)를 피할 수 없었습니다. <br> 
   
  이 문제를 회피하기 위해 병렬 커넥션이나 파이프라인 커넥션이 도입되었지만, <br>
  성능 개선에 대한 근본적인 해결책은 되지 못했습니다. <br> 
   
  HTTP/1.1 명세가 발표된 지 십수 년 동안, 이 성능 문제를 해결하고자 많은 이들이 노력을 해왔습니다. <br> 
  HTTP 작업 그룹은 HTTP/1.1이 발표되기도 전인 1997년 7월 HTTP-NG 프로젝트를 시작했으며, <br>
  HTTP/1.1의 저자 중 한 명인 로이 필딩은 WAKA라는 프로토콜을 제안했습니다. <br> 
  또 마이크로소프트는 Microsoft S+M(Speed+Mobility)이라는 프로토콜을 개발하기 시작했습니다. <br> 
   
  한편 2009년 구글은 웹을 더 빠르게 하겠다는 목표 아래 SPDY 프로토콜을 내놓았습니다. <br> 
  SPDY는 기존의 HTTP에 속도를 개선하기 위한 여러 기능을 추가한 것입니다. <br> 
  SPDY는 헤더를 압축하여 대역폭을 절약했고, 하나의 TCP 커넥션에 여러 요청을 동시에 보내 회전 지연을 줄이는 것이 가능했으며, <br> 
  클라이언트가 요청을 보내지 않아도 서버가 능동적으로 리소스를 푸시하는 기능도 갖추고 있었습니다. <br> 
   
  이 모두는 회전 지연을 줄이기 위한 것입니다. <br> 
  구글의 "SPDY: 더 빠른 웹을 위한 실험적인 프로토콜"에 따르면, SPDY를 적용했을 때 RTT(Round-trip delay time)가 20ms인 상황에서는 <br> 
  12.34%의 성능 개선 효과가 있었으며, 80ms인 상황에서는 23.85%, 200ms인 상황에서는 26.79%의 성능 개선 효과가 있었습니다. <br> 
   
  마침내 2012년 10월 3일, HTTP 작업 그룹은 SPDY를 기반으로 HTTP/2.0 프로토콜을 설계하기로 결정하였음을 메일링 리스트를 통해 밝혔습니다. <br> 
  HTTP 작업 그룹은 SPDY의 초안을 그대로 가져와서 HTTP/2.0 초안을 만들기 시작했습니다. <br> 
   
  2013년 11월 현재, HTTP/2.0은 여덟 번째 초안까지 나와 있으며, 아직까지는 SPDY의 특징들을 거의 그대로 유지하고 있습니다. <br> 
  크게 변경된 점이라면 헤더를 압축할 때, 더 이상 deflate 알고리즘을 사용하지 않게 되었다는 것 정도입니다. <br> 
   
</details>
 
-----------------------

### SPDY에서 헤더를 압축하는 이유는 무엇입니까? (기출) 

<details>
   <summary> 답안 보기 (👈 Click)</summary>
[참고: HTTP 완벽 가이드 p.288]
   
+ 
</details>
 
-----------------------

### HTTP/2.0은 어떻게 동작합니까? (기출) 

<details>
   <summary> 답안 보기 (👈 Click)</summary>
[참고: HTTP 완벽 가이드 p.288]
   
+ 
</details>
 
-----------------------


### MySQL과 MongoDB의 차이점은? (기출) 

<details>
   <summary> 답안 보기 (👈 Click)</summary>
[참고: ]
   
+    
</details>

-----------------------

### System Call이란? (기출) 

<details>
   <summary> 답안 보기 (👈 Click)</summary>
[참고: 쉽게 배우는 운영체제 p.51] 

+ 시스템 호출은 커널이 자신을 보호하기 위해 만든 인터페이스입니다. <br> 
  커널은 사용자나 응용 프로그램으로부터 컴퓨터 자원을 보호하기 위해 자원에 직접 접근하는 것을 차단합니다. <br> 
  따라서 자원을 이용하려면 시스템 호출이라는 인터페이스를 이용하여 접근해야 합니다. <br> 
   
  그렇다면 자원에 직접 접근하는 것과 시스템 호출을 통해 접근하는 것은 어떤 차이가 있을까? <br> 
  이를 쉽게 이해할 수 있도록 커피를 마시고 싶을 때, 직접 만들어 먹는 경우와 <br>
  다른 사람에게 만들어달라고 부탁하는 경우를 생각해보자. <br> 
   
  (1) 직접 접근
  - 사용자가 직접 컴퓨터 자원에 접근하여 작업하는 방식으로, 사용자가 모든 것을 처리해야 합니다. <br> 
    [그림 1-21]에서 보듯이, 사용자는 커피와 설탕이 어디에 있는지, 커피 머신을 어떻게 작동해야 하는지 등을 모두 알아야 합니다. <br> 
    이 경우는 자기 입맛에 맞는 커필르 만들 수는 있지만, 사용자의 부주의로 커피머신을 망가뜨리거나 주변을 더럽힐 수도 있습니다. <br> 
    즉, 커피 머신을 보호하기 어렵다는 단점이 있습니다. <br> 
  (2) 시스템 호출을 통한 접근
  - 누군가에게 요청하여 작업의 결과만 받는 방식입니다. [그림 1-21]에서 보듯이 사용자는 어떤 커피머신을 쓰는지, 어떻게 커피를 만드는지 등을 <br>
    신경쓸 필요 없이 결과만 받으면 됩니다. 이 경우는 사용자의 오작동이나 악의에 의해 커피머신이 망가지는 일도 막을 수 있습니다. <br> 
    이와 마찬가지로 운영체제는 사용자나 응용 프로그램이 하드웨어에 직접 접근하지 못하도록 막음으로써 컴퓨터 자원을 보호합니다. <br> 
    그리고 대신 하드웨어와 같은 시스템 자원을 사용할 수 있도록 인터페이스를 제공하는데 이것이 바로 시스템 호출입니다. <br> 
   
  이번에는 응용 프로그램의 입장에서 시스템 호출을 살펴봅니다. <br> 
  어떤 응용 프로그램은 숫자 14를, 또 어떤 응용 프로그램은 숫자 21을 하드디스크에 저장하려 한다고 가정합니다. <br> 
  
  (1) 직접 접근
  - 두 응용 프로그램이 자기 마음에 드는 위치에 데이터를 저장하려 할 것입니다. 이 경우 다른 사람의 데이터를 지울 수도 있고, <br> 
    내 데이터가 다른 사람에 의해 지워질 수도 있습니다. <br> 
   
  (2) 시스템 호출을 통합 접근
  - 응용 프로그램이 직접 하드디스크에 데이터를 저장하지 않고, 커널이 제공하는 write() 함수를 사용하여 데이터를 저장해달라고 요청합니다. <br> 
    응용 프로그램은 데이터가 하드디스크의 어느 위치에 어떤 방식으로 저장되는지 알 수 없습니다. <br> 
    만약 자신이 저장한 데이터를 읽고 싶다면 read() 함수로 시스템 호출을 이용하면 가져오면 됩니다. <br> 
    시스템 호출을 이용하면 커널이 데이터를 가져오거나 저장하는 것을 전적으로 책임지기 때문에 <br> 
    컴퓨터 자원을 관리하기가 수월합니다. 
   
</details>


-----------------------


### Docker와 Virtual Machine의 차이점은? (기출) 

<details>
   <summary> 답안 보기 (👈 Click)</summary>

+ 
</details>


-----------------------

### 방화벽이란? (기출) 

<details>
   <summary> 답안 보기 (👈 Click)</summary>
[참고: https://ko.wikipedia.org/wiki/%EB%B0%A9%ED%99%94%EB%B2%BD_(%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%82%B9)] 

+ 방화벽은 미리 정의도니 보안 규칙에 기반한, 들어오고 나가는 네트워크 트래픽을 모니터링하고 제어하는 네트워크 보안 시스템입니다. <br> 
  방화벽은 일반적으로 신뢰할 수 있는 내부 네트워크, 신뢰할 수 없는 외부 네트워크(ex) 인터넷) 간의 장벽을 구성합니다. <br> 
  서로 다른 네트워크를 지나는 데이터를 허용하거나 거부하거나 검열, 수정하는 하드웨어나 소프트웨어 장치입니다. <br>  
</details>


-----------------------

### 방화벽의 역할은 무엇입니까? 

<details>
   <summary> 답안 보기 (👈 Click)</summary>
[참고: https://ko.wikipedia.org/wiki/%EB%B0%A9%ED%99%94%EB%B2%BD_(%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%82%B9)] 

+ 방화벽의 기본 역할은 신뢰 수준이 다른 네트워크 구간들 사이에 놓여서 신뢰 수준이 낮은 네트워크로부터 오는 해로운 트래픽이 <br> 
  신뢰 수준이 높은 네트워크로 오지 못하게 막는 것입니다 <br> 
  흔히 네트워크 관리자의 입장에서 높은 신뢰도를 갖는 구간은 내부 네트워크 구간이라 하고, <br> 
  낮은 신뢰도를 갖는 구간은 인터넷 구간 또는 외부 네트워크 구간이라고 합니다. <br> 
   
  이 밖에도 외부에 서비스를 제공하는 서버들을 위한 DMZ 구간이 있으며, 인터넷으로부터 내부 네트워크로의 침입을 막는 동시에 <br> 
  내부 네트워크에서 인터넷과 자유롭게 통신할 수 있도록 도와줍니다. <br> 
   
  대부분의 방화벽은 정책 기반의 방화벽이며, 다양한 수준의 정책으로 네트워크 간의 트래픽을 제어합니다. <br>
   
  - 일반 수준의 정책: 외부에서 내부로 전송되는 모든 트래픽을 차단하거나 허용합니다. <br>
  - 고급 수준의 정책: "외부의 경쟁회사.com으로부터 내부 서버 가짜정보.net으로 오는 길이 500바이트 이상의 http 트래픽을 허용하되 로그를 남긴다."와 같은 복잡한 정책 <br> 
</details>


-----------------------


### CI/CD란? (기출) 

<details>
   <summary> 답안 보기 (👈 Click)</summary>

+ 
</details>


-----------------------


### CORS란? (기출) 

<details>
   <summary> 답안 보기 (👈 Click)</summary>
[참고: https://developer.mozilla.org/ko/docs/Web/HTTP/CORS]    

+ 교차 출처 리소스 공유는 추가 HTTP 헤더를 사용하여, 한 출처에서 실행 중인 웹 애플리케이션이 다른 출처의 선택한 자원에 접근할 수 있는 권한을 <br> 
  부여하도록 브라우저에 알려주는 체제입니다. 웹 애플리케이션은 리소스가 자신의 출처(도메인, 프로토콜, 포트)와 다를 때, <br> 
  교차 출처 HTTP 요청을 실행합니다. <br> 
</details>

-----------------------

### CORS의 예시는 어떠합니까?  

<details>
   <summary> 답안 보기 (👈 Click)</summary>
[참고: https://developer.mozilla.org/ko/docs/Web/HTTP/CORS]    

+ https://doamin-a.com의 프론트엔드 Javascript 코드가 XMLHttpRequest를 사용하여 https://domain-b.com/data.json을 요청하는 경우 <br> 
  보안 상의 이유로, 브라우저는 스크립트에서 시작한 교차 출처 HTTP 요청을 제한합니다. <br> 
  예를 들어, XMLHttpRequest와 Fetch API는 동일 출처 정책을 따릅니다. 즉, 이 API를 사용하는 웹 애플리케이션은 자신의 출처와 <br>
  동일한 리소스만 불러올 수 있으며, 다른 출처의 리소스를 불러오려면 그 출처에서 올바른 CORS 헤더를 포함한 응답을 반환해야 합니다. <br> 
  
  ![image](https://user-images.githubusercontent.com/8718430/211547444-63b9ac96-5c4f-43d1-aac5-87e186738923.png)

  CORS 체제는 브라우저와 서버 간의 안전한 교차 출처 요청 및 데이터 전송을 지원합니다. <br> 
  최신 브라우저는 XMLHttpRequest 또는 Fetch와 같으느 API에서 CORS를 사용하여 교차 출처 HTTP 요청의 위험을 완화합니다. <br> 
</details>

-----------------------

### Fetch API란 무엇입니까?  

<details>
   <summary> 답안 보기 (👈 Click)</summary>
[참고: https://developer.mozilla.org/ko/docs/Web/HTTP/CORS]    

+ 
</details>

-----------------------
